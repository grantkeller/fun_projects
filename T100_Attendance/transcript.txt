Hello class. Welcome to the pre-recorded video. I'm going to be talking about cryptography, which is a challenging subject and honestly deserves multiple semesters worth of content. It could almost be its own major really. But we're going to talk about him about an hour. Just kinda summary, summarizing some things about it. The thing about cryptography, I probably like to point out first is that it's really we wouldn't be able to have cybersecurity. At least we wouldn't be able to have good cybersecurity without it. So I consider it the cornerstone of cybersecurity. Along with things like policy and good network configuration and firewalls and stuff like that. Cybersecurity is essential to being able to not just handle confidentiality, integrity of transfers, and so on. I don't know what we would do without it. And you might think cryptography is something that is just recent. It's something that we've only used, maybe, you know, about its use during World War II. But it goes back quite a ways. And the earliest recorded use of that we have of cryptography is with Julius Caesar of all people. 2000 years ago he hired somebody or utilized, or maybe he developed his own use of a cryptographic cipher in which you actually just shifted the characters in the alphabet over to substitute each character with one that was three to the left or five to the right, or some type of shift. And we'll talk about that a little bit more later. But cryptography has widely been used in war time. And it's been charged with keeping track of the world secrets. And in a large way, we would probably have a very different world without cryptography because certain battles would have been won or lost with it or without it. It really was a game changer. Once we got to World War II. Prior to World War II, cryptic cryptography was mostly something that humans did with math. And how to do by hand, try to, try to crack it by hand, try to develop it by hand. But in the early part of the 20th century, maybe starting with World War one, actually, we started to utilize electronic devices to be able to both make cryptography possible or at least use more advanced ciphers, but also to try to crack cryptographic codes that were being sent that use those ciphers. Charles Babbage, who invented the Babbage engine back in the 19th century, had actually cracked one of the, well, one of the earlier classical crypto, cryptographic ciphers called the veneer cipher, which we'll talk about in a second. But his work on that with largely unknown until later. Anyways. After, after the, if you've ever watched a movie about the Enigma machine, There's been a few. Was it called? The one that's about Alan Turing with Benedict Cumberbatch. Can think of the name of it right now, but anyways, that's a good one. It shows how with the newer ciphers, it really demands a stronger knowledge of math. And especially since the days of the Enigma and the cipher that it used, we've had to start utilize more advanced mathematics like modern algebra, abstract algebra, and so on, in order to be able to make the more advanced cryptographic ciphers possible. So if you remember back to probably elementary school or high school or maybe even college. And somebody raised their hand and said, when I'm at going to use this in real life, well, you can use it in real life. It's for these types of things that you use it for. It's just that math has become so much more advanced than the cutting edge of science and technology that there's always more math that you can learn to do something new with it. So cryptography is one of those cutting edge things that utilizes the more advanced math that you learn in college. Okay? So the first type of, okay, Yeah, the first type of cipher I'm going to talk about as a substitution cipher. This is the type that Caesar used long time ago, it's paid and you've probably seen this type of cipher being used in like kids puzzles and stuff like that. But basically you're replacing one letter with another symbol. And the book. I don't really like. Sometimes the way the book portrays the textbook that you're in, portray certain things. So I want to try and clear some things up. But it doesn't have to mean replacing old character with something shifted by a certain number of characters for every single character, you can actually substitute. In this case, I'm showing a J for an a, a wife, or a B. That's not a, that's not a consistent shift for each character. That's a varying shifts. So you're coming up with a different letter for each character. And it can even be a symbol. There was a patent methionine. So Jasmine's just musician that I listened to. And he released an album that on the front use symbols to spell out Pat methionine group imaginary day or something. It was an album called imaginary day, but he used these iconic iconography for the letters. And that was basically a substitution cipher. You're using something that isn't the normal meaning of the letters to mean those meaning of the letters. So for instance, here, we're using this substitution cipher where this letter on the left is what the actual meaning is. But then the letter on the right of each of these tables is the cipher symbol that's being used in that place. So a message like, I'm sorry. A message like take them from the East becomes t. You can find the t here and that becomes a b. The a becomes a j, the K becomes an S, and so on. So each of those normal letters get substituted with some character symbol that the book says something about. It's like if you shifted every letter to the, to the the right by five, that gives the impression that it's a transposition cipher or something like that, or that it always has to be that way and it doesn't. It just means replacing the symbol with something else. Okay, So let me move my video around so you can see the slides. Actually, I'll probably just hide my face. Okay? The problem with a substitution cipher though, is that almost every language has, I mean, by its nature, has a more frequent use of certain characters. Like in English, the letter E is the most common character. In normal texts. Like if you were to take a book and you were to analyze the frequency of the letters, you would end up with a chart that something like this where E, T, and a are the most common letters that are going to be used and followed by 0. And then once you get down to the, the less frequent ones that kinda shifts around depending on the texts that you're analyzing. But for instance, in the ciphertexts, if somebody were to capture the ciphertexts that I had to take them from the East turning into BJ S, S PEBO, PI, and so on. They were to analyze the frequency of the letters. Then applied this frequency like here, I've, I've taken the frequency and p and b are the two most common letters. They happen to have the same frequency, but they're the two most common letters in the ciphertext. So if I assign them to be E and T, I can start to try to decipher the ciphertext using that. Of course, this isn't a very long message, so it's gonna be hard to actually do a proper analysis of it. But you can kinda get the idea and if you play around with it and maybe change some of the letters like here I switched the 0 and the J. And maybe I'm able to get a couple more of the letters to take on their meaning and just play around with it for awhile. Now I've switched the S and the 0. So you can start to see the take them. This one doesn't show up very well because it has less frequent letters that are used in English. But that starts to show up. And then from East almost as their and stuff. So as things start to show up, after you do this frequency analysis, with a larger amount of text, you're going to have more accurate results when you do this frequency analysis. But this is just showing one of the weaknesses of the substitution cipher. And how it gets attacked. Obviously, you know, 11 major problem with a substitution cipher is that once, you know, once you know the substitution key, like what substitutions are being made, you can perhaps decode all the other messages that were sent using that substitution. Like if Caesar was always using a shift of five, and he never changed that. Then once you decode one, you're going to know the secret and you're gonna be able to decode all the other messages and maybe all the messages going forward. So it's, it's kinda a weak cipher. But it was mankind's first attempt at doing these types of things. It's interesting, it goes back so far. The next type of cipher is the transposition cipher. And both of these ciphers can be used in tandem as kinda principles of how you can actually scramble up characters to show different things. But this basically just involves moving the letters around. Not changing the meaning of the letters, but changing where they're located in the actual text. The way this is usually done is you take, you decide how long of a row length you're going to have for the different columns that are going to, your ciphertext is going to go into. So here I've taken this message, we will attack at dawn on Thursday. And I've put them into this five column grid. And then followed by padding at the end. That's used to just kind of make it so that you don't have spaces or blanks or something like that. You use some kind of character that will end up being at the end as a pad. Just to kind of pad things off. It's kinda like when I was talking about base-64 encoding. And you have those, you might have an equal sign or double equal sign or something at the end. Same kind of principle. But anyways, so if I chose a row length of five, I mean it could be 5678 or whatever. You want to choose something long enough but short enough that your whole message isn't going to, isn't going to be like the length of the rows. But anyways, so you type in we will, and then you wrap it around attack at dawn on Thursday. Then what you do as you shift around, you shift around the row, the columns. And you can shift around the columns. But the one thing you can do is actually just read the characters out from top to bottom. And then that's how you get your ciphertext. Another method you can use this to actually shift the columns around and then read the, the, the, the columns from top to bottom. Of course, this is a very easy one to decode it just a matter of shifting the columns back or figuring out what the row length is. And so if you want to attack this type of cipher, you just have to play with the different row counts until it ends up making something that's meaningful. But of course, this is a useful concept for being able to apply with other types of cipher techniques so that it can be used in tandem. Like for instance, if you wanted to use a substitution and transposition cipher together, along with a key, you can get something that's fairly strong. So again, showing the substitution cipher, I probably shouldn't put this slide a little bit earlier, but this is the one that was used by Julius Caesar. Basically he just replaced every character with one that was three to the right, three places to the right and the alphabet. So in other words, an e becomes a be, an m becomes a j, and so on. The f becomes the C and so on. Don't think of this as a transposition. Transposition is not where you're replacing the characters. I know that the wording can be a little bit confusing, but they're two different things. Transposition means you're basically moving the characters around. But a substitution means you're replacing the character width, something else. It doesn't have to be a constant shift. Shift to the right. It can be with any symbol. So maybe replay that part of the video again so that you get it. But you don't want to confuse those two, especially given the way the book explains it. And maybe some of the other texts that you might find online will explain it in a way that's a little bit confusing. So you have to be careful about the meaning there. So I'm actually recording this. You probably can't really tell. But I'm recording this. Video from my hotel room in Stockholm, Sweden. It's the end of the week of spring break. I just came from Paris, France. We spent like a week in Paris, France, my family. And it's kind of interesting to be talking about cryptography because a lot of the cryptography was developed in Europe and was used in Europe. More so than in the United States. I mean, the classical crypto was developed here. And the vision year cipher was named after somebody who basically described it in the 19th century. I think. Although it had been invented, I guess by a monk back in the 1500s. But it's a cipher that basically is a substitution cipher and uses a key along with it. So instead of just shifting, instead of just always replacing a character by a set other character, you're using a key to provide the shift of which character to replace it with. So in other words, if you have a message like cat, C-A-T, and you want to use a key of dog or something like that, you would take the C and you shift it by d and you get an F. And then a would be shifted by an 0, 0, 0 for that. So CO, and then the T and the g would end up crying a z. So you'd get cozy for a ciphertext, maybe not, maybe kind of obvious or something. But anyways, I'll show you a more sophisticated example in a second. But I mean, cryptography was used by the Germans for the Enigma machine. You know, the, the crypto analysts at Bletchley Park in England who were under the instruction of MI6. I guess. They are trying to crack the Enigma code. And they had to develop basically the first computer or one of the first computers to be able to do it, because they had to try so many different codes. So cryptography is often something that's at the cutting edge of everything. Okay? Rambling on and getting onto a sidetrack on different subjects. But anyways, so yeah, if you can think about this chart and it's kinda like your multiplication tables or something like that. It's kinda like that when you're in third or fourth grade and you're doing your multiplication tables. But here it's just showing if you have the key on the message characters on one side and you have the key characters here. What do they create the ciphertext. Okay, so here's a demo of that. Let's say you have the message, the suit is the lute, and you're using a key of dog. And so you take the T and you shift it by the letter d. And so if you come over here and you say, okay, the message characters t, and I want to shift it by dy, I get a W because fifth column over there is the ciphertext, so I get w here. I do the same thing. When I reached the end of the key, I repeat the key. So it's like DOD DOJ, DRG throughout the message. And it just gets repeated over and over again. So you can see how this generates a ciphertext that's unintelligible. You can't really tell what's going on until you start to see that one of its weaknesses is if you happen to have a key that matches up with the same plain text, you end up generating the same ciphertext. And so this ended up being its weaknesses. That was discovered. That if you can figure out the same ciphertext, you might be able to figure out at least the length of the key, or at least a multiple of the length of the key. By finding a place where it matches up, the ciphertext matches up with in some way. Then you can do some things to try to figure out what the key is based on that. A little bit beyond this lecture. Okay? So the book also talks about some things you should know about crypto, cryptography implementation. One thing to really note here that the book doesn't really talk about. But it's important to know as a cybersecurity professional is that oftentimes it's not the cryptographic cipher that gets broken. It's the implementation that gets broken someplace. A programmer or developer, a system administrator, a DevOps person, they end up making a mistake some place. Either they don't follow the instructions closely enough. They don't use a proper random number source. Or there's a problem with the crypto library that they're using. The crypto service provider that is made by Microsoft or whatever. Then that ends up being the undoing that ends up compromising the the sensitive data. Back in 2014, it was Heartbleed, which was a vulnerability in the OpenSSL crypto, cryptographic library that a lot of programs we're using that ended up leading to a major breach of security. And that wasn't a problem with the ciphers themselves. It was a problem with the way the cryptographic library was being written. It had a vulnerability in it. A lot of times some application will be written and the developer won't properly use the library the way they should be or they didn't read the directions properly or something like that. Or maybe they store the key in a way that's vulnerable, like the key that's being used for the encryption or something like that. They don't set the proper permissions on a file, on the file system, something like that ends up being the undoing of this whole communications process between the client, the server. And you can see how when you're, the client and the server are talking to each other and using this common or maybe different cryptographic ciphers for the two in the front. That on each side, the client has to get it right and the server has to get it right. They might have their own random number sources and crypto libraries and key storage places and ways of protecting them and stuff like that. So a lot can go wrong other than the cipher itself. So that's when the book tries to talk about cryptography implementation problems. This is what it's getting at. In my experience, it's often where the crypto fails is somewhere in the implementation of a story I have is one of my jobs. There's a guy who was actually from Europe, from Ireland. But he came over to visit the headquarters that I worked at. And he was really proud of a he, he wanted to replace the SSH authentication mechanism with one that he wrote himself. And anytime somebody ever says, I made, I made my own crypto, I made my own authentication mechanism or something like that run the other way. I put this in one of the slides, but you want to run the other way, or at least stop them from doing something like that. Because a lot of work has to go into making cryptographic ciphers and cryptographic implementations work properly. It's not a game for the faint of heart. It's something that you have to know. A lot of. You have to have a strong math background. You have to know all the potential pitfalls of and so on. And so we spent like a half-hour trying to convince this guy that it wasn't a good idea for him to be replacing the SSH as authentication mechanism with his own. His way of doing it had a vulnerability in that you could sense it wasn't even an authentication mechanism that was part of SSH. He basically set up so SSH would just let anybody in. And then there was a wall that was his authentication mechanism. But the problem with that is that as soon as you authenticate successfully through SSH, you can do things like set up proxies, like you can proxy or traffic through SSH. So even though he was blocking people from accessing like the shell, people could still do things over the proxy connection and stuff like that. So it was really not a good thing. So we put a stop to that. Okay. So on this previous slide I mentioned random number source. So random numbers are something that are very important to cryptographic ciphers because you need them for doing things like creating keys. You have to create random thousand, 24 bit or 128 bit keys that get used to actually do the encryption. And the reason why it's important that the numbers are random is because you don't want an adversary to be able to predict what your key was, right? You have to be able to generate something that's completely random. You're, you're, you're most used to generating random passwords. And it's kind of like that. But for instance, when you, on the first day of class, when you generate an SSH key and you create a passphrase for it. There are two things going on there. The first one was the SSH was generate SSH key gen. The program that generates a key was choosing a random thousand 24 bit value that acted as the real key. Then you were asked to put in a passphrase. And what that does is it protects the key from just being randomly decrypted and looked at. There's actually two keys there. There's the real key that actually is being used for encrypting your SSH data. And then there's the key that's protecting the SSH key. Both are important, but it shows how random number generation is actually really important in cryptography. So you have to make sure that you have a good random number generator. And that's difficult to do on a computer because the computer is a deterministic machine. It's just following algorithms. It's like how can you tell it to, it's like telling the computer how can imagine something. And it's like how can you tell a computer to imagine a cloud or something that it has no concept of, or something like that. The way they've been doing this is by using these pseudo-random number generators, which just use the CPU and it uses a special algorithm with what's called a seed value, basically a starting number. And that starting number just helps too, um, make the algorithm goes through a sequence and give you random, give you seemingly random values. But the truth is, is that after a certain amount of time, those values are going to repeat. So you have to, you have to watch out for that kind of thing. But of course, lot of times the random values repeat after two to the 40th times or something like that. So it's often, you don't run into the repeating issue. But a lot of people who care about strong cryptography, they want to have a true random number generating source. And the way they do this is by, you know, like maybe setting up a sensor that's sensing radio waves or radioactive decay of an element or something like that. Something that is a physical process that you can't predict what's going to happen. You can, you can print. You can maybe use mouse movements or keyboard strokes or something like that, or hard drive actuator noise or something like that to try to generate random data. And that'll, that'll work. But sometimes it has its own problems. You can't generate enough random data at once. And so you have to wait for it to, for your computer to collect more random noise. So you have to like move your mouse around and stuff like that. But it's a stronger form of random number generation. Then, like I said, crypto can fail based on random number generation. Sometimes people have been able to crack cryptographic ciphers because they were able to figure out based on the CPU that you have in your computer or something. What what the random number sequence would have been used, or something like that. Along time ago it was popular to actually publish. Along with DNS records, the the CPU value of the server and stuff like that, like in text records. But that actually wasn't a good idea because it ended up leading to people being able to predict what random number generation so you are using and you're able to figure out what random number sequence somebody had used. Then you have Crypto Service Provider library. So on Windows it's called a crypto service provider. It's, it's some kind of API that gets used by the programs for handling your ciphers. On Linux and Mac, we call them cryptographic libraries. That can be something like OpenSSL or Lieber SSL. Lieber SSL is a replacement for OpenSSL. And then sometimes there's even, there's commercial ones as well and so on. But what this is meant to do is it makes it so that the developer can just use cryptography and they don't have to worry about the very complicated math that needs to be done in order to handle the cryptography and makes sure that the person is working properly. But the developers still needs to make sure that they're reading the documentation well and following the rules and guidelines of that documentation. Like I said, a lot of times crypto is hacked because of poor implementation. You also have to make sure that if you're generating some kind of key, that you have to protect that key so that it can't just be easily read. For instance, when you generate an SSH key is going to put inside your dot SSH directory. And SSH generally doesn't let you use it unless you have strong permission set on the key. So you have to usually set your dot SSH directory, so it's only readable by the user. And the, the key itself has only readable by the user. Of course, the root user can see it. But anyways, also ensure that you have a good random number source. There's also some sometimes like web servers and mail servers and stuff like that. Server software will warn you if your key is not protected, like if it doesn't have good permissions or something like that. Okay. Yeah, like I said, beware of people who are claiming that we wrote our own crypto. There's this syndrome that plagues computer companies that makes them take too long to get their products to market called not invented here syndrome. And so it means that they don't want to go with somebody else's solution, they want to come up with their own. And so sometimes people do this for cryptography. And it's just not a good thing. There is a company that recently spammed me that talks about this concept called micro sharding. And they want to do a demo for me or something like that. Actually, I want to see the demo so I can see how they're actually handling the micro charting. Because basically from what I can tell, what they're doing is they're dividing up the data. That's supposed to be sensitive data like social security numbers, PII, data and so on. And they're dividing it up into little pieces that become meaningless. Like if you were to divide up each character into its own bit of data, then they move those bits of data around the cloud. They moved them so that they're not altogether in one place. But of course, if you're, if you can, maybe pause the video for a second and just try to think of how you could attack that. Then when you think you have some ideas, come back and I'll explain how that can be easily attacked. The problem I see there is that there always is a, there has to be some kind of controller, right? That brings all the data back together. If that controller gets attacked and somebody compromises the controller, they're going to have the pointers to all, where all the bits of data are stored and bring them all back together. But this company, shard safe or something like that, was claiming that this was an alternative, a secure alternative to cryptography. And I'm like, Why don't you just use cryptography? Just use cryptography. It's proven. It's like, it's not something that you have to invent yourself or whatever. You just have to follow the directions or something. I don't understand what this company is trying to do with this micro sharding business, but it sounds like snake oil to me. So you have to watch out for people who make those kind of claims. The other thing that you have to think about is that whenever a new cryptographic cipher comes along, it takes about ten or 15 years before. It's actually used in the industry. So this recently we've been using AES-256 and 1,192.1, 28. But those were actually developed as part of a contest by the National Institute of Standards and Technology, nist. Nist back in the '90s there was a contest and the AES cipher, which was originally called Rain doll, which is, it's a norse word. Actually I'm in, I'm in Stockholm. It kinda makes sense. I'm talking about this. So Randall was the winning algorithm that won this contest, but this was back in the '90s. We didn't actually end up using that AES algorithm until probably the early 2010s or so. So took about ten years before they actually started using it. And it was meant to replace an algorithm that was developed back in the '70s called DES, or maybe it was in the 60s. Anyways, there's developed a long time ago for the government called DES. Des algorithm had become weak over time. And so we knew algorithms need to be made. Okay, Moving along and probably rambling on too much caching. We've already gone over this in the course, so I think, I think you have a good handle on it. But basically this is just where you use a cryptographic algorithm rhythm to generate a hash, a unique hash value, that's a uniform length. This is where you use the shot to 56, some Shaw, five-twelfths, some MD5 sum is another one that you'll commonly see, but MD5 sum is now considered obsolete and has been broken. So you shouldn't be using that anymore. Some people are still using it. And the idea of ion hashing is that you're not gonna be able to generate a unique value, but you can't find the reverse of that value just by decrypting it or something like that. You have to, the only way you can find it is by brute forcing, like trying every possible value and seeing if it generates the hash that you're expecting. Of course this takes forever. And on the weaker hashing algorithms, you're going to find collisions before you find, maybe before you find the actual value or whatever collision is where two different plain texts generate the same hash value. K. And collisions have been found in MD5. In fact, I generate a collision one time. That was the Purdue logo and the IU. I think I showed this to Purdue logo and the IU logo. And they both generate the same hash value. Anyways, so key strengths, the key strength, and you might think of this as password strength, but it's a little bit different. The length matters just like it does in password strength. So a longer length of key values. So this key value could be a bunch of random digits all strung together. And so when we talk about bits, we're talking about like the 1, 0, 1, 1, 1 0 0, 1, 1 0, 0, 1, 1, 1, like that, on and off bits and stuff like that. Now those get grouped together until bytes. But when we're talking about cryptography, cryptography, we are talking about the length of the bits. And so a longer key is going to mean a stronger key because in order to crack that random, that random code that's used for the key, you have to try more permutations. And this is where the powers of two come into play. If it was a, it was a key of length two. So it's only a two bit key, then it's two to the two, which is four. So there's only four different combinations before you would crack the key with something like two to the 40th, then it would be two to the 40th power in a 30-second power being 4.2 billion, possibilities to the 40th would be bigger than that. So 40 bit keys were the maximum that the United States allowed software, software developers to use in commercially distributed software until the late 990s. And other words, they weren't able to develop software and export it if, unless it was less than 40 bits strong. So before 1999, if you wanted to use a stronger encryption scheme, you had to get a special license for it and you had to prove that you are a citizen of the United States and stuff like that because they considered this military grade stuff. If you wanted to have 128 bit cryptographic cipher, you had to get permission from the government to use it because they think they thought of it as military secrets. Even though you're just talking about using a longer bit, longer bit key. And so nowadays, 128 bit is considered the standard minimum for any type of symmetric cryptography. Symmetric cryptography meaning that the same key is used on both sides. And then if it's asymmetric, crypto 2048-bit is concerned the standard minimum. The reason for the difference there is just because of the way asymmetric crypto works, it needs to have a much larger bit key in order for it to be as strong, the equivalence to be as strong. For one. Because with a with asymmetric crypto, There's a public key that's being published. It's like whenever you go to a website and you're going to the HTTPS version of the website, you're actually seeing a public certificate, right? So if you want to be able to crack the key that's being used to sign that certificate. You're going to need to, It's gonna be exposed to a whole lot more people and so on. Okay. So longer key requires more computational power to use, but it's going to protect you for a longer amount of time. So if you, if you choose to use like a 256 bit symmetric key instead of 128 bit, that's going to take more computational power on the server side and the client side to be able to use. Excuse me, had a big dinner. But it's also going to be harder to crack. If somebody wants to crack that, it's going to take them a longer amount of time. To be able to crack it. And again, you have to generate the key data from a strong random source. And just to give you an idea of what the threat is here, as far as key strength goes. You know, computers are getting more powerful the time when I was born in the '70s. And Mike, microcomputers had just been developed. They were brand new on the scene. And the concept of microcomputers, you probably don't even understand what I'm talking about, but you had the computers that took up the whole room, right. And that was the normal that was a normal computer. They they thought of that as a computer until about the 1960s or '70s. They thought all computers have to be as big as a room or something. There's a famous quote in a magazine called Popular Science that in the future computer, and this was in the 1950s. It said in the future computers may weigh less than 1.5 tons, which is just silly because now you have a computer that fits in your pocket and stuff like that. And even you have ones that can fit on a penny and stuff. But the computers from that era were weaker computationally than your phone. They filled a room and they took like kilowatts of power to be able to, maybe even a megawatt of power to run. But they were only able to do like 50,000, maybe. I don't know, ten to 50,000 computations per second, whereas your phone can do about 1 billion computations per second. So there's quite a big difference in scale. With each advance that we have in computing. There's the increased threat against the key strength in cryptography. So when it was the Enigma machine in this British bomb, It's, the machine was called BOM, BOM BE. And this was the system that was developed at Bletchley Park. And Alan Turing worked on and it was to find the initial settings that were used on the Enigma machine. But this is as big as a person and took a while to run and stuff like that. But I mean, these days we could, we could compute the Enigma combinations in seconds or something on a phone. In the '70s. At about the time when that DES, cipher was developed. A popular computer of the time was this PDP 11, which is like, it's like a refrigerator size computer. And there were more things that went with it, but the main computing unit was about the size of a refrigerator. And so they develop the ciphers. Thinking that people were using these types of machines and not really thinking of in the future how much faster things will be moving much further ahead to 2012. There's this. You have in gaming computers, you have GPUs which are meant to accelerate graphics. But within cryptography, we've, we've learned that you can use GPUs as a general math accelerator for certain types of math operations. And you can crack passwords and mine Bitcoins with them and stuff like that. So back in 2012, somebody made a 25 GPU powered password cracker. And this is just one of the servers that was part of that group. I mean, this one only has eight GPUs in it. But this had a total of 25. And I was able to try 348 billion hashes per second. In other words, it was able to try 348 billion combinations per second. So if you can think about how strong your password is, and they had to try all the combinations to try to guess what your plain text password was. They were they were able to crack most people's passwords within a matter of minutes with this machine. And this was using off the shelf hardware. And you might say, well, who's going to be able to afford this? The bad guys can afford it. Guess what? Governments can afford this kind of stuff. And so that's your threat. That's the people that you need to be worried about. Now on the horizon. And actually here right now is quantum computing. We've been talking about this for the past 1015 years or so. Cryptographic algorithms are going to, that we currently rely on today will become obsolete because quantum computers may be able to crack them within seconds. Because quantum computers are going to be able to try all the combinations at the same time using something called cubits. Whenever you see a picture of this, it looks, you call it like the quantum chandelier. It looks like a chandelier or something like that. This isn't actually the quantum computer. What this is is it's all the cooling, the cooling device that is needed to bring the quantum chip and the cubits down to a very low temperature. People think of this whole thing is the quantum computer kinda like when you look at it, people say, oh, the CPU and they point to the computer. And it's like, well, that's just the case in it's like the CPU is a little chip inside or something that's kinda the same thing. So this is all the cooling. It's a bunch of copper tubing and stuff like that. That's basically like a big radiator. That brings the temperature down to like negative to earn 70 bolt down to like five Kelvin or something like that. Negative to earn 68 below zero Celsius. Okay? So an exercise I want you to try is to open up your red desktop. And first of all, think of a strong passphrase to use for your key. Like a dice where passphrase like cocktails, safety, recycle, hours. I'm reading stuff in front of my in front of my face right now. Actually it's funny, I'm in Sweden, but most of the stuff in the room is in English. It's amazing how many people in Europe speak English fluently. We're really kind of, It's a shame for not learning or languages as well as the Europeans do. But anyways, so think of a strong passphrase and then go into the red desktop and open up two terminals like this. Like I've just opened up two different terminals. One of them ended up being red for some reason, and one black. Anyways. So the first thing you'll do is you're going to use this pipeline command to basically encrypt a message. So I'm going to be using the AES-256 electronic code book cipher to encrypt this. That might, might or might not be the best cipher to use. But I really just want to give you the experience of encrypting something at a low level to see how it's done. Okay? I'm going to say, I don't know. The king's gold is kept in the castle wall or something. And then I'm going to pipe that into this OpenSSL per gram, which OpenSSL is normally a library, but this is a program that is a front end to that library and allows you to interface with the different ciphers. So we're going to use this AES-256. We type in AES-256 ECB. And then the reason why we pipe this into, actually the first thing I'm gonna do is pipe it into hex dump. Dump is just a program that will show you the hexagon hex, hexadecimal representation of the bits from the encrypted message. And the reason why I'm doing this is because if I were to not do it, you're going to end up with some binary garbage. Screen-sharing paused. Screen-sharing is paused. Okay? So I'm sorry, I have to re-share the share my whole screen. Share Firefox, okay? Okay. Hopefully you can see that. Okay. So if I were to do this without something, I'm just going to type in password is password. Let's see, it generates all this binary garbage and you can see that says salted at the beginning. And that just means that it chose a random salt value to use with the encryption so that the same encrypted text doesn't generate the same cipher text twice. So this time I'm going to pass into hex dump. And that way you can kinda see the binary data a little bit easier. I'm just going to type in a simple passphrase. Here. This is the address at which the values are stored, but this is the actual data like here, but it's just in a hexadecimal representation. So here's something that I understand is that because these computers are in what's called Big Endian form, every hexadecimal pair is flipped. So this is actually the first character. This is the second character. This is the third characters. This is the fourth character. Not gonna get into this much more, I think I talked about before. But yeah, so anyways, this is S a L T, and it goes salted and so on. Then the actual binary data, excluding this address column is here. And so if I run this again and I use the same password, it asks you to type it in twice just to confirm that you got it right. You'll see that the actual encrypted data is different this time because it used a different soul. And so this makes it harder for somebody to crack it. The reason why I'm going to pass it into base 64, as in your exercise, it because if it's in base 64, it's easy to copy from one terminal to the other or send it to somebody and actually have them decrypt it. So you can imagine here that you have a friend and you're sending the secret message and out-of-band, you've told your friend the password, maybe you met them at a at a bar or something or well, not bar but at a restaurant or something. I remember you guys as age. And you gave them the password that they're going to be able to use to decrypt the message, type in password twice. Then you get this base-64 encrypted value. I copy this Shift and Control and C are for copy on a terminal. Or you can come up here and say Copy. And then over here, I'm going to paste this in first. Whoops, okay, it copied the new line as well. So I need to first of all, copied part of it. It's weird. Puts a new line in. You know what? I I might have. You tried this. I might have. Okay. You might have to copy one line at a time. So paste and then copy this copy, paste. Alright, so now we're going to go to the beginning of that line and you go to the beginning of the line in the command line, you can press Control a. In press Control E to go to the end, control a to go to the beginning. We'll go the beginning, type in echo, go in and type in pipe. And if you just, if you run this without the pipe or anything else is just going to print that to the string. But if you put in the pipe, it's going to send that value to the input of whatever program we're going to run after it. So now we're gonna decrypt. We're going to say OpenSSL. And it's the same, a 256 ECB. But this time we're gonna give it a d option for decrypt. Oh, okay, First of all, I need to turn this base-64 encoded data into something that that OpenSSL, AES-256 ECB is kinda understand. So I need to dq dy code the base-64 string. And then the decoded string is going to be piped into open SSL AES-256, um, thing. So hit Enter. And then I type in password. I type in the password that I, you know, I transferred to my friend and then there's a secret message. So maybe the first thing you notice is how easy it was for me to make a mistake. It's like I almost made a mistake a few times. And just the implementation of something simple here. And you can, you can end up with little implementation problems and stuff like that. But I just wanted to show you how you could do some simple encryption using these programs and stuff like that. There's online programs that you can use as well that they might find interesting. If you just search for cryptographic and characters and web pages that will do it for you or something like that. You can play around with OpenSSL. If you run OpenSSL without any arguments, just like, I'm sorry. Okay, maybe give it a dash H. You'll see a bunch of cipher. It gives you a bunch of help. But the last bit of help that gives you Are these different ciphers that you can run so you can see how DES is there. And also a T5, T6, CBC and ECB and so on. Are there base 64? Is there, even though it's not really a cipher, it's an encoder. So it's base-64 isn't a wow. Yeah, it's, it's not, it's not considered a cryptographic cipher. Even though some people might be able to argue that it's a substitution cipher because you're substituting not specific letters but sets of bits. But the point wasn't to, for it to be confidential, it's known that it's not confidential because you publish the key along with it. Anyways, getting back to slides real quick. Before we call it a night. This is probably gone on way too long. But there's also the attendance word that I want you to write in for the attendance is what's the name of the city that I'm actually in right now that I said in this video. And there's also some other videos in the slides. If you find that you didn't understand something that was talking about in this, because cryptography is hard to understand. It's pretty complex. There's some other videos I've included in here that you might, to get some clarification. Alright, Well, thanks a lot, and I'll see you guys in class. Bye. 